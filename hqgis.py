# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Hqgis
                                 A QGIS plugin
 Access the HERE API in QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-12-22
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Riccardo Klinger
        email                : riccardo.klinger@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QUrl
from PyQt5.QtGui import QIcon, QColor
from PyQt5.QtWidgets import QAction, QFileDialog, QMessageBox
from PyQt5 import QtGui, QtWidgets, QtNetwork
from functools import partial
# Initialize Qt resources from file resources.py
from .resources import *
from .GetMapCoordinates import GetMapCoordinates
# Import the code for the dialog
from .hqgis_dialog import HqgisDialog
from .decodeGeom import decode
from .mapCat import mapCategories
import os.path
import requests
import json
import urllib
import os
from qgis.core import QgsProject, QgsVectorLayerSimpleLabeling, QgsPalLayerSettings, QgsTextFormat
from PyQt5.QtGui import QFont
from .apikey import API_KEY
from PyQt5.QtCore import QVariant, QDateTime
from qgis.core import (
    QgsApplication,
    QgsPoint,
    QgsSymbol,
    QgsRendererRange,
    QgsGraduatedSymbolRenderer,
    QgsPointXY,
    QgsGeometry,
    QgsMapLayerProxyModel,
    QgsVectorLayer,
    QgsProject,
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform,
    QgsFeature,
    QgsField,
    QgsMessageLog,
    QgsNetworkAccessManager,
    QgsProcessingFeatureSourceDefinition,
    QgsProcessing,
    QgsVectorLayerUtils,
    QgsSettings)
from qgis.PyQt.QtWidgets import QProgressBar
from qgis.PyQt.QtCore import *
from qgis.utils import iface
from Hqgis.HqgisProvider import HqgisProvider
import math
import processing  # Importar la librerÃ­a de procesamiento

class Hqgis:
    def __init__(self, iface):
        self.provider = HqgisProvider()
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Hqgis_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = HqgisDialog()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Hqgis')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'Hqgis')
        self.toolbar.setObjectName(u'Hqgis')
        self.getMapCoordinates = GetMapCoordinates(self.iface)
        self.getMapCoordTool = None
        self.listOfExpandedPoints = []
        self.optimumTime = {}

    # noinspection PyMethodMayBeStatic
    def tr(self, message):

        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Hqgis', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToWebMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        QgsApplication.processingRegistry().addProvider(self.provider)
        icon_path = ':/plugins/hereqgis/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Access the HERE API'),
            callback=self.run,
            parent=self.iface.mainWindow())
        
        self.dlg.calcIsoButtonBatch.setEnabled(True)
        self.dlg.calcIsoButtonBatch.clicked.connect(self.getIsochronesBatch)
        

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        QgsApplication.processingRegistry().removeProvider(self.provider)
        for action in self.actions:
            self.iface.removePluginWebMenu(
                self.tr(u'&Hqgis'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    def enableButtons(self):
        self.dlg.calcIsoButtonBatch.setEnabled(True)

    def enableTime(self, lineEdits):
        if lineEdits[0].currentText() == "enabled":
            lineEdits[1].setEnabled(True)
        else:
            lineEdits[1].setEnabled(False)
            print("time disabled")

    def enableBatchISO(self):
        self.dlg.calcIsoButtonBatch.setEnabled(True)

    def convertGeocodeResponse(self, responseAddress):
        geocodeResponse = {}
        try:
            geocodeResponse["Label"] = responseAddress["address"]["label"]
        except BaseException:
            geocodeResponse["Label"] = ""
        try:
            geocodeResponse["Country"] = responseAddress["address"]["country"]
        except BaseException:
            geocodeResponse["Country"] = ""
        try:
            geocodeResponse["State"] = responseAddress["address"]["state"]
        except BaseException:
            geocodeResponse["State"] = ""
        try:
            geocodeResponse["County"] = responseAddress["address"]["county"]
        except BaseException:
            geocodeResponse["County"] = ""
        try:
            geocodeResponse["City"] = responseAddress["address"]["city"]
        except BaseException:
            geocodeResponse["City"] = ""
        try:
            geocodeResponse["District"] = responseAddress["address"][
                "district"
            ]
        except BaseException:
            geocodeResponse["District"] = ""
        try:
            geocodeResponse["Street"] = responseAddress["address"]["street"]
        except BaseException:
            geocodeResponse["Street"] = ""
        try:
            geocodeResponse["HouseNumber"] = responseAddress["address"][
                "houseNumber"
            ]
        except BaseException:
            geocodeResponse["HouseNumber"] = ""
        try:
            geocodeResponse["PostalCode"] = responseAddress["address"][
                "postalCode"
            ]
        except BaseException:
            geocodeResponse["PostalCode"] = ""
        try:
            geocodeResponse["Relevance"] = responseAddress["scoring"]["queryScore"]
        except BaseException:
            geocodeResponse["Relevance"] = None
        try:
            geocodeResponse["CountryQuality"] = responseAddress["scoring"]["fieldscore"][
                "country"
            ]
        except BaseException:
            geocodeResponse["CountryQuality"] = None
        try:
            geocodeResponse["CityQuality"] = responseAddress["scoring"]["fieldscore"]["city"]
        except BaseException:
            geocodeResponse["CityQuality"] = None
        try:
            geocodeResponse["StreetQuality"] = responseAddress["scoring"]["fieldscore"][
                "street"
            ][0]
        except BaseException:
            geocodeResponse["StreetQuality"] = None
        try:
            geocodeResponse["NumberQuality"] = responseAddress["scoring"]["fieldscore"][
                "houseNumber"
            ]
        except BaseException:
            geocodeResponse["NumberQuality"] = None
        try:
            geocodeResponse["MatchType"] = responseAddress["resultType"]
        except BaseException:
            geocodeResponse["MatchType"] = ""
        return geocodeResponse

    def createGeocodedLayer(self):
        layer = QgsVectorLayer(
            "Point?crs=EPSG:4326",
            "AddressLayer",
            "memory"
        )
        layer.dataProvider().addAttributes([
            QgsField("id", QVariant.Int),
            QgsField("oldAddress", QVariant.String),
            QgsField("address", QVariant.String),
            QgsField("country", QVariant.String),
            QgsField("state", QVariant.String),
            QgsField("county", QVariant.String),
            QgsField("city", QVariant.String),
            QgsField("district", QVariant.String),
            QgsField("street", QVariant.String),
            QgsField("number", QVariant.String),
            QgsField("zip", QVariant.String),
            QgsField("relevance", QVariant.Double),
            QgsField("qu_country", QVariant.Double),
            QgsField("qu_city", QVariant.Double),
            QgsField("qu_street", QVariant.Double),
            QgsField("qu_number", QVariant.Double),
            QgsField("matchtype", QVariant.String)
        ])
        layer.updateFields()
        return (layer)

    def createPlaceLayer(self):
        layer = QgsVectorLayer(
            "Point?crs=EPSG:4326",
            "PlaceLayer",
            "memory"
        )
        layer.dataProvider().addAttributes([
            QgsField("id", QVariant.String),
            QgsField("title", QVariant.String),
            QgsField("label", QVariant.String),
            QgsField("distance", QVariant.Double),
            QgsField("categories", QVariant.String)
        ])
        layer.updateFields()
        return (layer)

    def createPlaceLayerBatch(self):
        layer = QgsVectorLayer(
            "Point?crs=EPSG:4326",
            "PlaceLayerBatch",
            "memory"
        )
        layer.dataProvider().addAttributes([
            QgsField("id", QVariant.String),
            QgsField("origin_id", QVariant.Int),
            QgsField("title", QVariant.String),
            QgsField("label", QVariant.String),
            QgsField("distance", QVariant.Double),
            QgsField("categories", QVariant.String)
        ])
        layer.updateFields()
        return (layer)

    def createIsoLayer(self):
        layer = QgsVectorLayer(
            "Polygon?crs=EPSG:4326",
            "isoLayer",
            "memory"
        )
        layer.dataProvider().addAttributes([
            QgsField("id", QVariant.Int),
            QgsField("range", QVariant.Int),
            QgsField("metric", QVariant.String),
            QgsField("mode", QVariant.String),
            QgsField("traffic", QVariant.String),
            QgsField("timestamp", QVariant.DateTime),
            QgsField("type", QVariant.String)
        ])
        layer.updateFields()

        return (layer)

    def createIsoLayerBatch(self):
        layer = QgsVectorLayer(
            "Polygon?crs=EPSG:4326",
            "isoLayer",
            "memory"
        )
        layer.dataProvider().addAttributes([
            QgsField("id", QVariant.Int),
            QgsField("origin_id", QVariant.Int),
            QgsField("range", QVariant.Int),
            QgsField("metric", QVariant.String),
            QgsField("mode", QVariant.String),
            QgsField("traffic", QVariant.String),
            QgsField("timestamp", QVariant.DateTime),
            QgsField("type", QVariant.String)
        ])
        layer.updateFields()

        return (layer)

    def createRouteLayer(self):
        layer = QgsVectorLayer(
            "Linestring?crs=EPSG:4326",
            "RouteLayer",
            "memory"
        )
        layer.dataProvider().addAttributes([
            QgsField("id", QVariant.Int),
            QgsField("distance", QVariant.Double),
            QgsField("time", QVariant.Double),
            QgsField("mode", QVariant.String),
            QgsField("traffic", QVariant.String),
            QgsField("timestamp", QVariant.DateTime),
            QgsField("type", QVariant.String)
        ])
        layer.updateFields()
        return (layer)

    def messageShow(self, progress, count, max):
        if not progress:
            progressMessageBar = iface.messageBar().createMessage(
                "Looping through " + str(max) + " records ...")
            progress = QProgressBar()
            progress.setMaximum(max)
            progress.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            progressMessageBar.layout().addWidget(progress)
            iface.messageBar().pushWidget(progressMessageBar, level=1)
            iface.mainWindow().repaint()
        #    return progress
        if progress:
            progress.setValue(count)
        return (progress)

    def geocode(self):
        self.getCredentials()
        address = self.dlg.AddressInput.text()
        if address == "":
            address = "11 WallStreet, NewYork, USA"
        url = (
            "https://geocode.search.hereapi.com/v1/geocode?apiKey="
            + self.appId
            + "&q="
            + address
        )
        r = requests.get(url)
        try:
            # ass the response may hold more than one result we only use the
            # best one:
            responseAddress = json.loads(r.text)["items"][0]
            geocodeResponse = self.convertGeocodeResponse(responseAddress)
            lat = responseAddress["position"]["lat"]
            lng = responseAddress["position"]["lng"]
            layer = self.createGeocodedLayer()
            fet = QgsFeature()
            fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(lng, lat)))
            fet.setAttributes([
                0,
                address,
                geocodeResponse["Label"],
                geocodeResponse["Country"],
                geocodeResponse["State"],
                geocodeResponse["County"],
                geocodeResponse["City"],
                geocodeResponse["District"],
                geocodeResponse["Street"],
                geocodeResponse["HouseNumber"],
                geocodeResponse["PostalCode"],
                geocodeResponse["Relevance"],
                geocodeResponse["CountryQuality"],
                geocodeResponse["CityQuality"],
                geocodeResponse["StreetQuality"],
                geocodeResponse["NumberQuality"],
                geocodeResponse["MatchType"]
            ])
            # print("feature set")
            pr = layer.dataProvider()
            pr.addFeatures([fet])
            QgsProject.instance().addMapLayer(layer)
        except Exception as e:
            print(e)

    def batchGeocodeField(self):
        import time
        self.getCredentials()
        Resultlayer = self.createGeocodedLayer()
        pr = Resultlayer.dataProvider()
        layer = self.dlg.mapLayerBox.currentLayer()
        features = layer.getFeatures()
        ResultFeatureList = []

        # let's create the progress bar already with the number of features in
        # the layer
        progressMessageBar = iface.messageBar().createMessage(
            "Looping through " + str(layer.featureCount()) + " records ...")
        progress = QProgressBar()
        progress.setMaximum(layer.featureCount())
        progress.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        progressMessageBar.layout().addWidget(progress)
        iface.messageBar().pushWidget(progressMessageBar, level=0)
        i = 0
        for feature in layer.getFeatures():
            url = "https://geocode.search.hereapi.com/v1/geocode?apiKey=" + \
                self.appId + "&q=" + feature[self.dlg.fieldBox.currentField()]
            r = requests.get(url)
            try:
                responseAddress = json.loads(r.text)["items"][0]
                geocodeResponse = self.convertGeocodeResponse(responseAddress)
                lat = responseAddress["position"]["lat"]
                lng = responseAddress["position"]["lng"]
                ResultFet = QgsFeature()
                ResultFet.setGeometry(
                    QgsGeometry.fromPointXY(
                        QgsPointXY(
                            lng, lat)))
                ResultFet.setAttributes([
                    feature.id(),
                    feature[self.dlg.fieldBox.currentField()],
                    geocodeResponse["Label"],
                    geocodeResponse["Country"],
                    geocodeResponse["State"],
                    geocodeResponse["County"],
                    geocodeResponse["City"],
                    geocodeResponse["District"],
                    geocodeResponse["Street"],
                    geocodeResponse["HouseNumber"],
                    geocodeResponse["PostalCode"],
                    geocodeResponse["Relevance"],
                    geocodeResponse["CountryQuality"],
                    geocodeResponse["CityQuality"],
                    geocodeResponse["StreetQuality"],
                    geocodeResponse["NumberQuality"],
                    geocodeResponse["MatchType"]
                ])
                ResultFeatureList.append(ResultFet)
            except Exception as e:
                print(e)
            i += 1
            progress.setValue(i)

            # time.sleep(0.3)
            # time.sleep(0.3)
        pr.addFeatures(ResultFeatureList)
        iface.messageBar().clearWidgets()
        QgsProject.instance().addMapLayer(Resultlayer)

    def batchGeocodeFields(self):
        import time
        import sys
        self.getCredentials()
        # mapping from inputs:

        Resultlayer = self.createGeocodedLayer()
        pr = Resultlayer.dataProvider()
        indexer = {}
        layer = self.dlg.mapLayerBox_2.currentLayer()
        indexer["country"] = layer.fields().indexFromName(
            self.dlg.CountryBox.currentField())
        indexer["state"] = layer.fields().indexFromName(
            self.dlg.StateBox.currentField())
        indexer["county"] = layer.fields().indexFromName(
            self.dlg.CountyBox.currentField())
        indexer["postalCode"] = layer.fields().indexFromName(
            self.dlg.ZipBox.currentField())
        indexer["city"] = layer.fields().indexFromName(
            self.dlg.CityBox.currentField())
        indexer["street"] = layer.fields().indexFromName(
            self.dlg.StreetBox.currentField())
        indexer["houseNumber"] = layer.fields().indexFromName(
            self.dlg.NumberBox.currentField())
        ResultFeatureList = []  # got result storing
        # precreate field-lists for API call:
        addressLists = {}
        for key in indexer.keys():
            if indexer[key] != -1:
                parts = []
                oldIDs = []
                features = layer.getFeatures()
                for fet in features:
                    oldIDs.append(fet.id())
                    parts.append(str(fet.attributes()[indexer[key]]))
                addressLists[key] = parts
                addressLists["oldIds"] = oldIDs

        # let's create the progress bar already with the number of features in
        # the layer
        progressMessageBar = iface.messageBar().createMessage(
            "Looping through " + str(layer.featureCount()) + " records ...")
        progress = QProgressBar()
        progress.setMaximum(layer.featureCount())
        progress.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        progressMessageBar.layout().addWidget(progress)
        iface.messageBar().pushWidget(progressMessageBar, level=0)

        for id in range(0, layer.featureCount()):
            urlPart = ""
            oldAddress = ""
            for key in addressLists.keys():
                if key != "oldIds":
                    urlPart += key + "=" + addressLists[key][id] + ";"
                    oldAddress += addressLists[key][id] + ","
            url = "https://geocode.search.hereapi.com/v1/geocode?apiKey=" + \
                self.appId + "&qq=" + urlPart[:-1]
            r = requests.get(url)
            if r.status_code == 200:
                if len(json.loads(r.text)["items"]) > 0:
                    # as the response may hold more than one result we only use
                    # the best one:
                    responseAddress = json.loads(r.text)["items"][0]
                    geocodeResponse = self.convertGeocodeResponse(
                        responseAddress)
                    lat = responseAddress["position"]["lat"]
                    lng = responseAddress["position"]["lng"]
                    ResultFet = QgsFeature()
                    ResultFet.setGeometry(
                        QgsGeometry.fromPointXY(
                            QgsPointXY(
                                lng, lat)))
                    ResultFet.setAttributes([
                        addressLists["oldIds"][id],
                        oldAddress,
                        geocodeResponse["Label"],
                        geocodeResponse["Country"],
                        geocodeResponse["State"],
                        geocodeResponse["County"],
                        geocodeResponse["City"],
                        geocodeResponse["District"],
                        geocodeResponse["Street"],
                        geocodeResponse["HouseNumber"],
                        geocodeResponse["PostalCode"],
                        geocodeResponse["Relevance"],
                        geocodeResponse["CountryQuality"],
                        geocodeResponse["CityQuality"],
                        geocodeResponse["StreetQuality"],
                        geocodeResponse["NumberQuality"],
                        geocodeResponse["MatchType"]
                    ])
                    ResultFeatureList.append(ResultFet)
            time.sleep(0.5)
            progress.setValue(id)
            # iface.mainWindow().repaint()
            time.sleep(0.5)
        pr.addFeatures(ResultFeatureList)
        iface.messageBar().clearWidgets()
        QgsProject.instance().addMapLayer(Resultlayer)
        self.dlg.exec_()

    def getCredentials(self):
        self.appId = API_KEY

    def getCredFunction(self):
        import webbrowser
        webbrowser.open('https://developer.here.com/')

    def saveCredFunction(self):
        s = QgsSettings()
        s.setValue("HQGIS/api_key", self.dlg.AppId.text())
        print("save credits")
        self.dlg.credentialInteraction.setText("")
        self.dlg.credentialInteraction.setText(
            "credentials saved to QGIS Global Settings")

    def loadCredFunction(self):
        s = QgsSettings()
        try:
            apikey = s.value("HQGIS/api_key", None)
            self.dlg.credentialInteraction.setText(
                "credits used from QGIS global settings")
            # self.dlg.AppId.setText(apikey)
            self.dlg.AppId.setText(API_KEY)
        except BaseException:
            self.dlg.credentialInteraction.setText(
                "no credits found in qgis global settings. Please check settings or save a new key")

    def loadFields(self):
        self.dlg.CountryBox.setLayer(self.dlg.mapLayerBox_2.currentLayer())
        self.dlg.StateBox.setLayer(self.dlg.mapLayerBox_2.currentLayer())
        self.dlg.CountyBox.setLayer(self.dlg.mapLayerBox_2.currentLayer())
        self.dlg.ZipBox.setLayer(self.dlg.mapLayerBox_2.currentLayer())
        self.dlg.CityBox.setLayer(self.dlg.mapLayerBox_2.currentLayer())
        self.dlg.StreetBox.setLayer(self.dlg.mapLayerBox_2.currentLayer())
        self.dlg.NumberBox.setLayer(self.dlg.mapLayerBox_2.currentLayer())
        self.dlg.CountryBox.setAllowEmptyFieldName(True)
        self.dlg.StateBox.setAllowEmptyFieldName(True)
        self.dlg.CountyBox.setAllowEmptyFieldName(True)
        self.dlg.ZipBox.setAllowEmptyFieldName(True)
        self.dlg.CityBox.setAllowEmptyFieldName(True)
        self.dlg.StreetBox.setAllowEmptyFieldName(True)
        self.dlg.NumberBox.setAllowEmptyFieldName(True)

    def loadField(self):
        self.dlg.fieldBox.setLayer(self.dlg.mapLayerBox.currentLayer())
        self.dlg.fieldBox.setAllowEmptyFieldName(True)

    def setGetMapToolCoordFrom(self):
        """ Method that is connected to the target button. Activates and deactivates map tool """
        if self.dlg.captureButton.isChecked():
            print("true FROM")
            self.iface.mapCanvas().unsetMapTool(self.getMapCoordTool)
            self.dlg.captureButton_2.setChecked(True)
            return
        if self.dlg.captureButton.isChecked() == False:
            self.iface.mapCanvas().setCursor(Qt.CrossCursor)
            print("false FROM")
            self.iface.mapCanvas().setMapTool(self.getMapCoordTool)
            self.dlg.captureButton_2.setChecked(False)
            return

    def setGetMapToolCoordTo(self):
        if self.dlg.captureButton_2.isChecked():
            print("true TO")
            self.dlg.captureButton.setChecked(True)
            self.iface.mapCanvas().unsetMapTool(self.getMapCoordTool)
            return
        if self.dlg.captureButton_2.isChecked() == False:
            print("false TO")
            self.iface.mapCanvas().setCursor(Qt.CrossCursor)
            self.dlg.captureButton.setChecked(False)
            self.iface.mapCanvas().setMapTool(self.getMapCoordTool)
            return

    def setGetMapToolCoordPlace(self):
        if self.dlg.captureButton_4.isChecked():
            self.iface.mapCanvas().unsetMapTool(self.getMapCoordTool)
            return
        if self.dlg.captureButton_4.isChecked() == False:
            self.iface.mapCanvas().setCursor(Qt.CrossCursor)
            self.iface.mapCanvas().setMapTool(self.getMapCoordTool)
            return

    def setGetMapToolCoordIso(self):
        if self.dlg.captureButton_3.isChecked():
            self.iface.mapCanvas().unsetMapTool(self.getMapCoordTool)
            return
        if self.dlg.captureButton_3.isChecked() == False:
            self.iface.mapCanvas().setCursor(Qt.CrossCursor)
            self.iface.mapCanvas().setMapTool(self.getMapCoordTool)
            return

    def geocodelineFrom(self):
        self.getCredentials()
        address = self.dlg.fromAddress.text()
        url = "https://geocode.search.hereapi.com/v1/geocode?apiKey=" + \
            self.appId + "&q=" + address
        r = requests.get(url)
        try:
            # ass the response may hold more than one result we only use the
            # best one:
            responseAddress = json.loads(r.text)["items"][0]
            # geocodeResponse = self.convertGeocodeResponse(responseAddress)
            lat = responseAddress["position"]["lat"]
            lng = responseAddress["position"]["lng"]
            self.dlg.FromLabel.setText(
                str("%.5f" % lat) + ',' + str("%.5f" % lng))
        except BaseException:
            print("something went wrong")

    def geocodeline(self, lineEdits):
        self.getCredentials()
        address = lineEdits[0].text()
        url = "https://geocode.search.hereapi.com/v1/geocode?apiKey=" + \
            self.appId + "&q=" + address
        r = requests.get(url)
        try:
            # ass the response may hold more than one result we only use the
            # best one:
            responseAddress = json.loads(r.text)["items"][0]
            # geocodeResponse = self.convertGeocodeResponse(responseAddress)
            lat = responseAddress["position"]["lat"]
            lng = responseAddress["position"]["lng"]
            lineEdits[1].setText(str("%.5f" % lat) + ',' + str("%.5f" % lng))
        except BaseException:
            print("something went wrong")
        try:
            if lineEdits[1].text() != "":
                lineEdits[2].setEnabled(True)
            else:
                lineEdits[2].setEnabled(False)
        except BaseException:
            print("routing")

    def checkPlacesInput(self):
        if self.dlg.placeLabel.text() != "" and len(
                self.dlg.listWidget.selectedItems()) > 0:
            self.dlg.findPOISButton.setEnabled(True)
        else:
            self.dlg.findPOISButton.setEnabled(False)

    def checkPlacesInputBatch(self):
        if len(self.dlg.listWidgetBatch.selectedItems()) > 0:
            self.dlg.findPOISButtonBatch.setEnabled(True)
        else:
            self.dlg.findPOISButtonBatch.setEnabled(False)

    def selectMetric(self):
        if self.dlg.metric.currentText() == "Time":
            self.dlg.travelDistances.setEnabled(False)
            self.dlg.travelTimes.setEnabled(True)
        else:
            self.dlg.travelDistances.setEnabled(True)
            self.dlg.travelTimes.setEnabled(False)

    def selectMetricBatch(self):
        if self.dlg.metricBatch.currentText() == "Time":
            self.dlg.travelDistancesBatch.setEnabled(False)
            self.dlg.travelTimesBatch.setEnabled(True)
        else:
            self.dlg.travelDistancesBatch.setEnabled(True)
            self.dlg.travelTimesBatch.setEnabled(False)

    def calculateRouteSingle(self):
        self.getCredentials()
        type = self.dlg.Type.currentText()
        mode = self.dlg.TransportMode.currentText()
        if mode == "pedestrian" or mode == "bicycle":
            type = "fast"
        traffic = self.dlg.trafficMode.currentText()
        url = "https://router.hereapi.com/v8/routes?apiKey=" + self.appId + "&return=polyline,summary&routingMode=" + type + \
            "&transportMode=" + mode + "&origin=" + \
            self.dlg.FromLabel.text() + "&destination=" + self.dlg.ToLabel.text()
        if self.dlg.trafficMode.currentText() == "default":
            # print(self.dlg.dateTimeEditBatch.dateTime())
            url += "&departure=" + \
                self.dlg.dateTimeEdit.dateTime().toString("yyyy-MM-dd'T'hh:mm:ss'Z'")
            time2 = self.dlg.dateTimeEdit.dateTime().toString("yyyyMMdd-hh:mm:ss")
            timestamp = QDateTime.fromString(time2, "yyyyMMdd-hh:mm:ss")
        else:
            timestamp = "any"
        print(url)
        r = requests.get(url)

        if r.status_code == 200:
            itemID = 0
            layer = self.createRouteLayer()
            pr = layer.dataProvider()
            features = []
            for section in json.loads(r.text)["routes"][0]["sections"]:
                print(section)

                try:
                    print("distance: " +
                          str(section["summary"]["length"]/1000) + " km"
                          " time: " +
                          str(section["summary"]["duration"]/60) + " min")

                    responseRoute = decode(section["polyline"])
                    vertices = []
                    for routePoint in responseRoute:
                        lat = float(routePoint[0])
                        lng = float(routePoint[1])
                        vertices.append(QgsPoint(lng, lat))
                    fet = QgsFeature()
                    print("succ1")
                    fet.setGeometry(QgsGeometry.fromPolyline(vertices))
                    print("succ2")
                    if not timestamp:
                        timerS = timestamp
                    else:
                        timerS = None
                    fet.setAttributes([
                        itemID,
                        section["summary"]["length"]/1000,
                        section["summary"]["duration"],
                        mode,
                        traffic,
                        timerS,
                        type
                    ])
                    features.append(fet)
                    itemID += 1
                    print(features)
                except Exception as e:
                    print(e)
            pr.addFeatures(features)
            QgsProject.instance().addMapLayer(layer)

    def getPlacesSingle(self):
        self.getCredentials()
        # radius = self.dlg.RadiusBox.value()
        categories = self.dlg.listWidget.selectedItems()
        categoriesList = []
        for category in categories:
            categoryID = mapCategories(category.text())
            categoriesList.append(categoryID)
        categories = ",".join(categoriesList)
        coordinates = self.dlg.placeLabel.text()
        url = 'https://browse.search.hereapi.com/v1/browse?at=' + coordinates + \
            "&categories=" + categories + "&limit=100&apiKey=" + self.appId
        r = requests.get(url)
        print(url)
        if r.status_code == 200:
            if len(json.loads(r.text)["items"]) > 99:
                iface.messageBar().pushMessage(
                    "Warning",
                    "The maximum number of POIs for original address at " +
                    coordinates +
                    " of 100 POIs reached.",
                    level=1,
                    duration=5)
            if len(json.loads(r.text)["items"]) > 0:
                try:
                    # as the response may hold more than one result we only use
                    # the best one:
                    responsePlaces = json.loads(r.text)["items"]
                    layer = self.createPlaceLayer()
                    features = []
                    for place in responsePlaces:
                        lat = place["position"]["lat"]
                        lng = place["position"]["lng"]
                        # iterate over categories:
                        categoriesResp = []
                        for cat in place["categories"]:
                            categoriesResp.append(cat["id"])
                        fet = QgsFeature()
                        fet.setGeometry(
                            QgsGeometry.fromPointXY(
                                QgsPointXY(
                                    lng, lat)))
                        fet.setAttributes([
                            place["id"],
                            place["title"],
                            place["address"]["label"],
                            place["distance"],
                            ";".join(categoriesResp)
                        ])
                        features.append(fet)
                    pr = layer.dataProvider()
                    pr.addFeatures(features)
                    QgsProject.instance().addMapLayer(layer)
                except Exception as e:
                    print(e)

    def getPlacesBatch(self):
        self.getCredentials()
        # radius = self.dlg.RadiusBoxBatch.value()
        categories = self.dlg.listWidgetBatch.selectedItems()
        categoriesList = []
        for category in categories:
            categoryID = mapCategories(category.text())
            categoriesList.append(categoryID)
        categories = ",".join(categoriesList)
        layer = self.createPlaceLayerBatch()
        # allow only regular point layers. no Multipoints
        originLayer = self.dlg.FindPOISLayer.currentLayer()
        if (originLayer.wkbType() == 4
            or originLayer.wkbType() == 1004
                or originLayer.wkbType() == 3004):
            self.iface.messageBar().pushWarning(
                'Failed', 'Please convert MultiPoint layer to Point layer before usage')
            return
        originFeatures = originLayer.getFeatures()
        layerCRS = originLayer.crs()
        if layerCRS != QgsCoordinateReferenceSystem(4326):
            sourceCrs = layerCRS
            destCrs = QgsCoordinateReferenceSystem(4326)
            tr = QgsCoordinateTransform(
                sourceCrs, destCrs, QgsProject.instance())
        progressMessageBar = iface.messageBar().createMessage(
            "Looping through " + str(originLayer.featureCount()) + " records ...")
        progress = QProgressBar()
        progress.setMaximum(originLayer.featureCount())
        progress.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        progressMessageBar.layout().addWidget(progress)
        iface.messageBar().pushWidget(progressMessageBar, level=0)
        i = 0
        for originFeature in originFeatures:
            if layerCRS != QgsCoordinateReferenceSystem(4326):
                # we reproject:
                geom = originFeature.geometry()
                newGeom = tr.transform(geom.asPoint())
                x = newGeom.x()
                y = newGeom.y()
            else:
                x = originFeature.geometry().asPoint().x()
                y = originFeature.geometry().asPoint().y()
            coordinates = str(y) + "," + str(x)
            url = 'https://browse.search.hereapi.com/v1/browse?at=' + coordinates + \
                "&categories=" + categories + "&limit=100&apiKey=" + self.appId
            r = requests.get(url)
            print(url)
            i += 1
            progress.setValue(i)
            iface.mainWindow().repaint()

            if r.status_code == 200:
                if len(json.loads(r.text)["items"]) > 0:
                    if len(json.loads(r.text)["items"]) > 99:
                        iface.messageBar().pushMessage("Warning", "The maximum number of POIs for original feature " +
                                                       str(originFeature.id()) + " of 100 POIs reached.", level=1, duration=5)
                    try:
                        # ass the response may hold more than one result we
                        # only use the best one:
                        responsePlaces = json.loads(r.text)["items"]
                        # layer = self.createPlaceLayer()
                        features = []
                        for place in responsePlaces:
                            lat = place["position"]["lat"]
                            lng = place["position"]["lng"]
                            # iterate over categories:
                            categoriesResp = []
                            for cat in place["categories"]:
                                categoriesResp.append(cat["id"])
                            fet = QgsFeature()
                            fet.setGeometry(
                                QgsGeometry.fromPointXY(
                                    QgsPointXY(
                                        lng, lat)))
                            fet.setAttributes([
                                place["id"],
                                originFeature.id(),
                                place["title"],
                                place["address"]["label"],
                                place["distance"],
                                ";".join(categoriesResp)
                            ])
                            features.append(fet)
                        print(features)
                        pr = layer.dataProvider()
                        pr.addFeatures(features)
                        QgsProject.instance().addMapLayer(layer)
                    except Exception as e:
                        print(e)

    
    def containsFeature(self, listFeatures, pointGeometry, currentCoordinate, time):
        for coordenada, arrayFeature in listFeatures.items():
            if coordenada != currentCoordinate:
                for feature in arrayFeature:
                    geometry = feature.geometry()
                    if geometry.contains(pointGeometry):
                        if coordenada not in self.listOfExpandedPoints:
                            self.listOfExpandedPoints.append(coordenada)
                            self.optimumTime[coordenada] = time
                        if currentCoordinate not in self.listOfExpandedPoints:
                            self.listOfExpandedPoints.append(currentCoordinate)
                            self.optimumTime[currentCoordinate] = time

                        return True
        
        return False
    

    
    # Convertir el tiempo de hours Decimals a hours, minutes y seconds
    def converTime(self, timeHours):
        hours = int(timeHours)
        minutesDecimals = (timeHours - hours) * 60
        minutes = int(minutesDecimals)
        seconds = int((minutesDecimals - minutes) * 60)
        return hours, minutes, seconds
    
    def calculateTimeInit(self, originLayer, layerCRS):
        speed = 40.0  # km/h
        points = []
        originFeatures = originLayer.getFeatures()
        for originFeature in originFeatures:
            if layerCRS != QgsCoordinateReferenceSystem(4326):
                sourceCrs = layerCRS
                destCrs = QgsCoordinateReferenceSystem(4326)
                tr = QgsCoordinateTransform(sourceCrs, destCrs, QgsProject.instance())
                geom = originFeature.geometry()
                newGeom = tr.transform(geom.asPoint())
                x = newGeom.x()
                y = newGeom.y()
            else:
                x = originFeature.geometry().asPoint().x()
                y = originFeature.geometry().asPoint().y()
            points.append((y, x))

        # Calcular todas las distancias y los tiempos entre cada par de puntos
        distances = []
        for i in range(len(points)):
            for j in range(i + 1, len(points)):
                lat1, lon1 = points[i]
                lat2, lon2 = points[j]
                distance = self.haversine(lat1, lon1, lat2, lon2)
                time = distance / speed
                distances.append((i, j, distance, time))

        # Encontrar la distancia con el tiempo mÃ¡s corto
        shortestDistance = min(distances, key=lambda x: x[3])

        # Obtener los Ã­ndices de los puntos, la distancia y el tiempo mÃ¡s corto
        i, j, min_distance, min_time = shortestDistance
        hours, minutes, seconds = self.converTime(min_time)

        return hours*60*60 + minutes*60 + seconds

        # FÃ³rmula de Haversine para calcular la distancia entre dos puntos en la Tierra
    def haversine(self,lat1, lon1, lat2, lon2):
        R = 6371.0  # Radio de la Tierra en kilÃ³metros
        dlat = math.radians(lat2 - lat1)
        dlon = math.radians(lon2 - lon1)
        a = math.sin(dlat / 2)**2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon / 2)**2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
        distance = R * c

        return distance
    
    def getIsochronesBatch(self):
        self.getCredentials()
        layer = self.createIsoLayerBatch()
        originLayer = self.dlg.IsoAddressBatch.currentLayer()
        # allow only regular point layers. no Multipoints
        if (originLayer.wkbType() == 4
            or originLayer.wkbType() == 1004
                or originLayer.wkbType() == 3004):
            self.iface.messageBar().pushWarning(
                'Failed', 'Please convert MultiPoint layer to Point layer before usage')
            return
        layerCRS = originLayer.crs()
        if layerCRS != QgsCoordinateReferenceSystem(4326):
            sourceCrs = layerCRS
            destCrs = QgsCoordinateReferenceSystem(4326)
            tr = QgsCoordinateTransform(sourceCrs, destCrs, QgsProject.instance())

        progressMessageBar = iface.messageBar().createMessage(
            "Looping through " + str(originLayer.featureCount()) + " records ...")
        progress = QProgressBar()
        progress.setMaximum(originLayer.featureCount())
        progress.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        progressMessageBar.layout().addWidget(progress)
        iface.messageBar().pushWidget(progressMessageBar, level=0)
        i = 0
        listFeatures = {}
        cantPoints = originLayer.featureCount()
        cutExpansion = False
        time = math.trunc((self.calculateTimeInit(originLayer, layerCRS)/3)) 
        print("time {}".format(time))
        cantRequest = 0
        mode = self.dlg.TransportModeBatch.currentText()
        if mode == 'public transport':
            mode = 'publicTransport'
        
        while ( (not cutExpansion) and cantRequest < 12):
            originFeatures = originLayer.getFeatures()
            for originFeature in originFeatures:
                if layerCRS != QgsCoordinateReferenceSystem(4326):
                    # we reproject:
                    geom = originFeature.geometry()
                    newGeom = tr.transform(geom.asPoint())
                    x = newGeom.x()
                    y = newGeom.y()
                else:
                    x = originFeature.geometry().asPoint().x()
                    y = originFeature.geometry().asPoint().y()
                
                coordinates = str(y) + "," + str(x)
                if (coordinates not in self.listOfExpandedPoints):
                    url = (
                        "https://isoline.router.hereapi.com/v8/isolines?origin="
                        + coordinates
                        + "&range[type]=time"
                        + "&range[values]="
                        + ",".join([str(time)])
                        + "&routingMode=short"
                        + "&transportMode="
                        + mode
                        + "&apiKey="
                        + self.appId
                    )

                    timestamp = None
                    url += "&departureTime=any"
                    # print(url)
                    r = requests.get(url)
                    cantRequest = cantRequest +1
                    i += 1
                    progress.setValue(i)
                    iface.mainWindow().repaint()
                    if r.status_code == 200:
                        if len(json.loads(r.text)["isolines"]) > 0:
                            try:
                                response = json.loads(r.text)["isolines"]
                                features = []
                                fid = 0
                                for line in reversed(json.loads(r.text)["isolines"]):
                                    for polygon in line["polygons"]:
                                        for key, value in polygon.items():
                                            Points = decode(value)
                                            vertices = []
                                            for Point in Points:
                                                lat = Point[0]
                                                lng = Point[1]
                                                p=QgsPointXY(lng, lat)
                                                if(not self.containsFeature(listFeatures, p, coordinates, time)):
                                                    vertices.append(p)
                                                else:
                                                    if len(self.listOfExpandedPoints) == cantPoints:
                                                        cutExpansion = True

                                            fet = QgsFeature()
                                            fet.setGeometry(
                                                QgsGeometry.fromPolygonXY([vertices]))
                                            fet.setAttributes(
                                                [fid, originFeature.id(), line["range"]["value"], 'time', mode, 'disable', timestamp, 'fast']
                                            )
                                            features.append(fet)
                                            fid += 1
                                
                                listFeatures[coordinates] = features
                                pr = layer.dataProvider()
                                pr.addFeatures(features)
                                layer.setOpacity(0.5)
                                QgsProject.instance().addMapLayer(layer)
                            except Exception as e:
                                print(e)
            try:
                # expansion en segundos
                timeExpantion = self.getTimeTheExpantion(listFeatures, layer)
                print("tiempo de avance calculado {}".format(timeExpantion))
                time = time + math.trunc((timeExpantion))
                # time = time + 20
                print("tiempo : {}".format(time))
                iface.messageBar().clearWidgets()
            except Exception as e:
                print(e)
                print("Error al calcular el tiempo de avance")

        layerPoints = self.dlg.IsoAddressBatch.currentLayer()
        # Al terminar el proceso
        message="\n Cantidad de request {} ".format(cantRequest)
        message+= "\n\n"
        for coordenada, tiempo in self.optimumTime.items():
            minutes = tiempo // 60
            secondsRestants = tiempo % 60
            p =  QgsPointXY(float(coordenada.split(',')[1]), float(coordenada.split(',')[0]))
            name = self.getIdPoints(layerPoints, p)
            if (secondsRestants != 0):
                message+="\n\n  Punto {} con tiempo optimo: {} minutes y {} seconds".format(name, minutes, secondsRestants)
            else:
                message+="\n\n  Punto {} con tiempo optimo: {} minutes".format(name, minutes)
        message += "\n\n"

        
        layer = self.createIsoLayerBatch()
        pr = layer.dataProvider()
        for coordenada, feature in listFeatures.items():
            pr.addFeatures(feature)

        cityLayer = QgsProject.instance().mapLayersByName("riocuarto")[0]
        # Transformar las capas a EPSG:3857 (Web Mercator)
        destCrs = QgsCoordinateReferenceSystem('EPSG:5347')
        def transformLayer(layer, destCrs):
            transformed_layer = processing.run('native:reprojectlayer', {
                'INPUT': layer,
                'TARGET_CRS': destCrs,
                'OUTPUT': 'memory:transformed'
            })['OUTPUT']
            
            return transformed_layer

        cityTransformed = transformLayer(cityLayer, destCrs)
        areasTransformed = transformLayer(layer, destCrs)

        # Crear la intersecciÃ³n
        params = {
            'INPUT': areasTransformed,
            'OVERLAY': cityTransformed,
            'OUTPUT': 'memory:'
        }

        result = processing.run('native:intersection', params)
        intersectedLayer = result['OUTPUT']

        # Calcular el Ã¡rea de las intersecciones
        intersectedLayer.startEditing()
        area_field_name = 'Area_Interseccion'
        intersectedLayer.dataProvider().addAttributes([QgsField(area_field_name, QVariant.Double)])
        intersectedLayer.updateFields()

        area_index = intersectedLayer.fields().indexFromName(area_field_name)

        for feature in intersectedLayer.getFeatures():
            geom = feature.geometry()
            area = geom.area()
            feature[area_index] = area
            intersectedLayer.updateFeature(feature)

        intersectedLayer.commitChanges()

        # Sumar el Ã¡rea total de las intersecciones
        totalIntersectedArea = sum([feature[area_field_name] for feature in intersectedLayer.getFeatures() if feature[area_field_name] is not None])
        # print(f"Ãrea interseccion : {totalIntersectedArea}")

        # Calcular el Ã¡rea total del Ã¡rea de servicio
        cityTransformed.startEditing()
        serviceAreaFieldName = 'Area_Servicio'
        cityTransformed.dataProvider().addAttributes([QgsField(serviceAreaFieldName, QVariant.Double)])
        cityTransformed.updateFields()

        servicio_area_index = cityTransformed.fields().indexFromName(serviceAreaFieldName)

        for feature in cityTransformed.getFeatures():
            geom = feature.geometry()
            if geom is None:
                print(f"Advertencia: geometrÃ­a nula en el feature ID {feature.id()}")
                continue
            area = geom.area()
            if area == 0:
                print(f"Advertencia: el Ã¡rea es 0 en el feature ID {feature.id()} con geometrÃ­a {geom.asWkt()}")
            feature[servicio_area_index] = area
            cityTransformed.updateFeature(feature)
            # print(f"Feature ID {feature.id()}, Ã¡rea: {area}")

        cityTransformed.commitChanges()

        totalServiceArea = sum([feature[serviceAreaFieldName] for feature in cityTransformed.getFeatures() if feature[serviceAreaFieldName] is not None])

        # print(f"Ãrea total del Ã¡rea de servicio: {totalServiceArea}")

        # Calcular el porcentaje de cobertura
        if totalServiceArea > 0:
            coverage_percentage = (totalIntersectedArea / totalServiceArea) * 100
            if coverage_percentage > 100 : coverage_percentage=100
            print(f"El porcentaje de cobertura es: {coverage_percentage:.2f}%")
            message += (f"El porcentaje de cobertura es: {coverage_percentage:.2f}%")
        else:
            print("El Ã¡rea total del Ã¡rea de servicio es 0, no se puede calcular el porcentaje de cobertura.")
            message+="\n El Ã¡rea total del Ã¡rea de servicio es 0, no se puede calcular el porcentaje de cobertura."
        
        dialog = QMessageBox()
        dialog.setWindowTitle("Datos de la salida")
        dialog.setText(message)
        dialog.exec()

    def getTimeTheExpantion(self, listFeatures, layer):
        layerPoints = self.dlg.IsoAddressBatch.currentLayer()
        distanceMin = float('inf')
        crs1 = layer.crs()
        print(f"CRS de la capa 1: {crs1.authid()}")
        crsProjected = QgsCoordinateReferenceSystem("EPSG:5347")
        transform1 = QgsCoordinateTransform(crs1, crsProjected, QgsProject.instance()) if crs1.isGeographic() else None
        arrayTuples = []
        for coordenada, arrayFeature in listFeatures.items():
            for coordenada2, arrayFeature2 in listFeatures.items():
                tuple1 = (coordenada, coordenada2)
                if (coordenada != coordenada2 and tuple1 not in arrayTuples):
                    arrayTuples.append((coordenada, coordenada2))
                    arrayTuples.append((coordenada2, coordenada))
                    feature = arrayFeature[0]
                    poly1 = feature.geometry()
                    feature2 = arrayFeature2[0]
                    poly2 = feature2.geometry()
                    if transform1:
                        poly1.transform(transform1)
                        poly2.transform(transform1)

                    p1 =  QgsPointXY(float(coordenada.split(',')[1]), float(coordenada.split(',')[0]))
                    name1 = self.getIdPoints(layerPoints, p1)
                    p2 =  QgsPointXY(float(coordenada2.split(',')[1]), float(coordenada2.split(',')[0]))
                    name2 = self.getIdPoints(layerPoints, p2)
                    distance = poly1.distance(poly2)
                    print("distancia {} de expansion {} con {}".format(distance, name1, name2))
                    if (distance < distanceMin and distance > 0):
                        distanceMin = distance
        
        speed = 40.0
        if distanceMin == float('inf') :
            distanceMin=0
        time = (distanceMin / 1000) / speed
        hours, minutes, seconds = self.converTime(time)
        return hours*60*60 + minutes*60 + seconds


    def getIdPoints(self, layerPoints, point):
        provider = layerPoints.dataProvider()
        features = provider.getFeatures()
        for feature in features:
            geometry = feature.geometry()
            x = geometry.asPoint().x()
            y = geometry.asPoint().y()
            if point.x() == x and point.y() == y:
                return feature.id()+1
            
        return -1

    def run(self):
        """Run method that performs all the real work"""
        # show the dialog
        self.dlg.show()
        # try to load credentials:

        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # get app code/id

            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
